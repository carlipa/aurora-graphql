{"version":3,"sources":["../../../src/factories/classes.fields.factory/generateClassesHelpers.js"],"names":[],"mappings":"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","file":"generateClassesHelpers.js","sourcesContent":["import {\n  GraphQLID,\n  GraphQLList,\n  GraphQLNonNull,\n} from 'graphql';\n\nimport {\n  connectionArgs,\n  connectionFromArray,\n} from 'graphql-relay';\n\nimport {\n  camelCase,\n  compact,\n  each,\n  isArray,\n  keys,\n  map,\n  pickBy,\n  startsWith,\n  upperFirst,\n} from 'lodash';\n\nimport { ClassesFieldsHelper } from './';\n\n/**\n * For each class, generate an object that contains information and methods for GraphQL\n * @private\n */\nexport default function generateClassesHelpers(classesFieldsHelper) {\n  if (!(classesFieldsHelper instanceof ClassesFieldsHelper)) {\n    throw new Error('`classesFieldsHelper` must be an instance `ClassesFieldsHelper`');\n  }\n\n  const classesNames = keys(classesFieldsHelper._classes.definitions).map((x) => x.toLowerCase());\n\n  each(classesNames, (className) => {\n    each(ClassesFieldsHelper.RESERVED_CLASS_PREFIX, (prefix) => {\n      if (startsWith(className.toLowerCase(), prefix.toLowerCase())) {\n        throw new Error(`Parse error: Cannot use reserved prefix \"${prefix}\" in \"${className}\"`);\n      }\n    });\n\n    if (ClassesFieldsHelper.RESERVED_CLASS_NAMES.map((x) => x.toLowerCase()).indexOf(className.toLowerCase()) !== -1) {\n      throw new Error(`Parse error: Cannot use reserved class name \"${className}\"`);\n    }\n  });\n\n  // Add the special \"file\" className\n  classesNames.push('file');\n\n  each(classesFieldsHelper._classes.definitions, (classDefinition, className) => {\n    let { fields: fieldsDefinitions, options } = classDefinition;\n\n    // If no options are needed, one can only use fieldDefs\n    if (!fieldsDefinitions && !options) {\n      fieldsDefinitions = classDefinition;\n      options = {};\n    }\n\n    /**\n     * Return the GraphQL fields of the class\n     * @param resolveRelations if false, the relations fields will be string or list of strings\n     * if false, they will be GraphQL type (default: true)\n     * @param disableNonNull if true, required field won't be GraphQLNonNull (default: false)\n     */\n    const getFields = ({ resolveRelations = true, disableNonNull = false } = {}) => {\n      const fields = {};\n\n      each(fieldsDefinitions, (field, fieldName) => {\n        const _fieldName = camelCase(fieldName);\n        if (ClassesFieldsHelper.RESERVED_FIELDS.indexOf(_fieldName) !== -1) {\n          throw new Error(`Parse error: Cannot use reserved field \"${fieldName}\"`);\n        }\n        each(ClassesFieldsHelper.RESERVED_FIELDS_PREFIX, (prefix) => {\n          if (startsWith(_fieldName.toLowerCase(), prefix.toLowerCase())) {\n            throw new Error(`Parse error: Cannot use reserved prefix \"${prefix}\" in field \"${_fieldName}\"`);\n          }\n        });\n\n        // Fields\n        if (isArray(field)) {\n          // If array\n          if (field.length !== 1) {\n            throw new Error('Parse error: Array must have a length of 1');\n          }\n          // You can use the object form, or directly enter the type\n          const fieldArrayData = (typeof field[0] === 'string') ? { type: field[0] } : field[0];\n          // If array of relation\n          if (fieldArrayData.type.toLowerCase() === 'relation') {\n            if (!fieldArrayData.ref) {\n              throw new Error('Parse error: \"relation\" needs a \"ref\"');\n            }\n\n            const _ref = fieldArrayData.ref.toLowerCase();\n            if (classesNames.indexOf(_ref) === -1) {\n              throw new Error(`Parse error: Found a reference to missing class \"${_ref}\"`);\n            }\n\n            if (resolveRelations) {\n              fields[_fieldName] = {\n                type: classesFieldsHelper._connections[_ref],\n                args: connectionArgs,\n                resolve: (fieldsList, args) => connectionFromArray(\n                  map(fieldsList[_fieldName], (id) => classesFieldsHelper._getClassDataById(_ref, id)),\n                  args\n                ),\n              };\n            } else {\n              fields[_fieldName] = {\n                type: new GraphQLList(GraphQLID),\n              };\n            }\n          } else if (fieldArrayData.type) {\n            fields[_fieldName] = {\n              type: new GraphQLList(ClassesFieldsHelper._graphQLTypeFromString(fieldArrayData.type)),\n            };\n          } else {\n            throw new Error(`Parse error: cannot parse field ${fieldName} in ${className}`);\n          }\n        } else {\n          // You can use the object form, or directly enter the type\n          const _field = (typeof field === 'string') ? { type: field } : field;\n\n          // If leaf\n          if (_field.type.toLowerCase() === 'relation') {\n            // If relation\n            if (!field.ref) {\n              throw new Error('Parse error: \"relation\" needs a \"ref\"');\n            }\n\n            const _ref = _field.ref.toLowerCase();\n            if (classesNames.indexOf(_ref) === -1) {\n              throw new Error(`Parse error: Found a reference to missing class \"${_ref}\"`);\n            }\n\n            if (resolveRelations) {\n              fields[_fieldName] = {\n                type: _field.required && !disableNonNull\n                  ? new GraphQLNonNull(classesFieldsHelper._types[_ref])\n                  : classesFieldsHelper._types[_ref],\n                resolve: (fieldsList) => classesFieldsHelper._getClassDataById(_ref, fieldsList[_fieldName]),\n              };\n            } else {\n              fields[_fieldName] = {\n                type: _field.required && !disableNonNull ? new GraphQLNonNull(GraphQLID) : GraphQLID,\n              };\n            }\n          } else if (_field.type) {\n            fields[_fieldName] = {\n              type: _field.required && !disableNonNull\n                ? new GraphQLNonNull(ClassesFieldsHelper._graphQLTypeFromString(_field.type))\n                : ClassesFieldsHelper._graphQLTypeFromString(_field.type),\n            };\n          } else {\n            throw new Error(`Parse error: cannot parse field ${fieldName} in ${className}`);\n          }\n        }\n\n        // Add the field description\n        fields[_fieldName].description = field.description;\n      });\n\n      return fields;\n    };\n\n    /**\n     * Returns an array that contains all the fields that are relation (one-to-one and one-to-many)\n     */\n    const getFieldsWithRelations = () => compact(map(fieldsDefinitions, (field, fieldName) => {\n      if (isArray(field) && field.length) {\n        // You can use the object form, or directly enter the type\n        const fieldArrayData = (typeof field[0] === 'string') ? { type: field[0] } : field[0];\n\n        if (fieldArrayData.type.toLowerCase() === 'relation') {\n          return {\n            fieldName: camelCase(fieldName),\n            className: fieldArrayData.ref,\n          };\n        }\n      } else if (field.type && field.type.toLowerCase() === 'relation') {\n        return {\n          fieldName: camelCase(fieldName),\n          className: field.ref,\n        };\n      }\n      return null;\n    }));\n\n    /**\n     * Returns an array which contains the name of the field that are not arrays nor relation\n     */\n    const getSortableFieldsName = () => compact(map(fieldsDefinitions, (field, fieldName) => {\n      if (isArray(field) || (field.type && field.type.toLowerCase() === 'relation')) {\n        return null;\n      }\n      return camelCase(fieldName);\n    }));\n\n    /**\n     * Returns a collection which contains the field that are not arrays\n     */\n    const getFilterableFields = () => pickBy(fieldsDefinitions, (field) => !(isArray(field)));\n\n    classesFieldsHelper.addClassHelper({\n      name: upperFirst(className),\n      plural: options && options.plural,\n      getFields,\n      getFieldsWithRelations,\n      getSortableFieldsName,\n      getFilterableFields,\n    });\n  });\n}\n"]}